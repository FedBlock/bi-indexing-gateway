#!/usr/bin/env node

/**
 * ÌÜµÌï© Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ïä§ÌÅ¨Î¶ΩÌä∏
 * ÏÇ¨Ïö©Î≤ï: npx hardhat run insert-data.js --network [hardhat_network]
 * ÏòàÏãú: npx hardhat run insert-data.js --network hardhat
 *       npx hardhat run insert-data.js --network monadTest
 *       npx hardhat run insert-data.js --network sepolia
 */

const { ethers } = require('hardhat');
const path = require('path');
const IndexingClient = require('../../indexing-client-package/lib/indexing-client');

// Î™ÖÎ†πÌñâ Ïù∏Ïûê ÌååÏã± (HardhatÏù¥ --network ÏûêÎèô Ï≤òÎ¶¨)
function parseArgs() {
  // indexNameÏùÑ ÏΩîÎìú ÎÇ¥ÏóêÏÑú Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏÑ§Ï†ï
  const indexName = 'samsung'; // Í∏∞Î≥∏Í∞íÏúºÎ°ú samsung ÏÇ¨Ïö©
  
  // Hardhat ÌôòÍ≤ΩÏóêÏÑú ÌòÑÏû¨ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏûêÎèô Í∞êÏßÄ
  const hardhatNetwork = process.env.HARDHAT_NETWORK || 'hardhat';
  
  // hardhatNetworkÏóê Îî∞Îùº network ÏûêÎèô ÏÑ§Ï†ï
  let network;
  if (hardhatNetwork === 'monad') {
    network = 'monad';
  } else if (hardhatNetwork === 'sepolia') {
    network = 'sepolia';
  } else if (hardhatNetwork === 'hardhat') {
    network = 'hardhat';
  } else {
    console.log('‚ùå ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Hardhat ÎÑ§Ìä∏ÏõåÌÅ¨:', hardhatNetwork);
    console.log('   ÏßÄÏõêÌïòÎäî ÎÑ§Ìä∏ÏõåÌÅ¨: hardhat, monad, sepolia');
    process.exit(1);
  }
  
  console.log(`\nüåê Hardhat ÎÑ§Ìä∏ÏõåÌÅ¨: ${hardhatNetwork}`);
  console.log(`üìã ÏûêÎèô ÏÑ§Ï†ï: network=${network}, index=${indexName} (Í∏∞Î≥∏Í∞í)`);
  
  return { network, indexName, hardhatNetwork };
}

// ÎÑ§Ìä∏ÏõåÌÅ¨Î≥Ñ ÏÑ§Ï†ï Ï†ïÎ≥¥ (ÎèôÏ†Å ÌååÏùºÎ™Ö ÏÉùÏÑ±)
function getNetworkConfig(network, indexName) {
  const configs = {
    hardhat: {
      IndexID: `001_${indexName}`,
      KeyCol: 'IndexableData',
      FilePath: `data/hardhat/${indexName}.bf`,
      Network: 'hardhat',
      DataType: 'IndexableData'
    },
    monad: {
      IndexID: `002_${indexName}`,
      KeyCol: 'IndexableData',
      FilePath: `data/monad/${indexName}.bf`,
      Network: 'monad',
      DataType: 'IndexableData'
    },
    fabric: {
      IndexID: `003_${indexName}`,
      KeyCol: 'Speed',
      FilePath: `data/fabric/${indexName}.bf`,
      Network: 'fabric',
      DataType: 'PVD'
    }
  };
  
  return configs[network];
}

// Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ Ìï®Ïàò
function calculateKeySize(data, keyCol) {
  if (keyCol === 'IndexableData') {
    // IndexableDataÏùò Í≤ΩÏö∞ OrganizationName Î¨∏ÏûêÏó¥ Í∏∏Ïù¥
    return data.OrganizationName ? data.OrganizationName.length : 32;
  } else if (keyCol === 'Speed') {
    // SpeedÏùò Í≤ΩÏö∞ Ïà´Ïûê Î¨∏ÏûêÏó¥ Í∏∏Ïù¥ (Î≥¥ÌÜµ 1-3ÏûêÎ¶¨)
    return data.toString().length;
  }
  return 32; // Í∏∞Î≥∏Í∞í
}

// Ïù∏Îç±Ïä§ Ï°¥Ïû¨ ÌôïÏù∏ Ìï®Ïàò (ÏûêÎèô ÏÉùÏÑ± Ï†úÍ±∞)
async function ensureIndexExists(indexingClient, network, config, actualKeySize) {
  try {
    console.log(`\nüîç Ïù∏Îç±Ïä§ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏: ${config.IndexID}`);
    
    // Ïù∏Îç±Ïä§ Ï†ïÎ≥¥ ÌôïÏù∏
    const existingInfo = await indexingClient.getIndexInfo({
      IndexID: config.IndexID,
      IndexName: `${network.toUpperCase()} Network - Speed Index`,
      KeyCol: config.KeyCol,
      FilePath: config.FilePath,
      KeySize: actualKeySize
    });
    
    if (existingInfo.ResponseCode === 200) {
      console.log(`‚úÖ Ïù∏Îç±Ïä§Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®: ${existingInfo.ResponseMessage}`);
      return true;
    } else if (existingInfo.ResponseCode === 500 && existingInfo.ResponseMessage.includes('already exists')) {
      // ÏùëÎãµ ÏΩîÎìú 500Ïù¥ÏßÄÎßå "already exists" Î©îÏãúÏßÄÍ∞Ä Ìè¨Ìï®Îêú Í≤ΩÏö∞
      console.log(`‚úÖ Ïù∏Îç±Ïä§Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®: ${existingInfo.ResponseMessage}`);
      return true;
    } else {
      // ÏßÑÏßúÎ°ú Ïù∏Îç±Ïä§Í∞Ä ÏóÜÎäî Í≤ΩÏö∞
      console.log(`‚ùå Ïù∏Îç±Ïä§Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå: ${existingInfo.ResponseMessage}`);
      console.log(`   Ïù∏Îç±Ïä§Î•º Î®ºÏ†Ä ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî: node create-index.js --cmd ${network}`);
      return false;
    }
  } catch (error) {
    console.log(`‚ùå Ïù∏Îç±Ïä§ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: ${error.message}`);
    console.log(`   Ïù∏Îç±Ïä§Î•º Î®ºÏ†Ä ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî: node create-index.js --cmd ${network}`);
    return false;
  }
}

// Hardhat/Monad ÎÑ§Ìä∏ÏõåÌÅ¨Ïö© Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ (EVM)
async function insertEVMData(network, config) {
  console.log(`\nüöÄ ${network.toUpperCase()} ÎÑ§Ìä∏ÏõåÌÅ¨ - EVM Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏãúÏûë...`);
  
  try {
    // 1. ÎÑ§Ìä∏ÏõåÌÅ¨Î≥Ñ Ïª®Ìä∏ÎûôÌä∏ Ï£ºÏÜå ÏÑ§Ï†ï
    let contractAddress;
    let networkConfig;
    
    switch (network) {
      case 'hardhat':
        contractAddress = "0x5FbDB2315678afecb367f032d93F642f64180aa3"; // Hardhat Î°úÏª¨
        networkConfig = { name: 'hardhat' };
        break;
      case 'monad':
        contractAddress = "0x4D393E83C47AFFA1eE8eaB8eFCcBD0d2e1835F97"; // Monad ÌÖåÏä§Ìä∏ÎÑ∑
        networkConfig = { name: 'monad' };
        break;
      case 'sepolia':
        contractAddress = "0x1234567890123456789012345678901234567890"; // Sepolia ÌÖåÏä§Ìä∏ÎÑ∑
        networkConfig = { name: 'sepolia' };
        break;
      default:
        throw new Error(`ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÎÑ§Ìä∏ÏõåÌÅ¨: ${network}`);
    }
    
    console.log(`üåê ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑ§Ï†ï: ${networkConfig.name}`);
    console.log(`üìù Ïª®Ìä∏ÎûôÌä∏ Ï£ºÏÜå: ${contractAddress}`);
    
    // 2. ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÌôïÏù∏
    const provider = ethers.provider;
    const networkInfo = await provider.getNetwork();
    console.log(`üîó Ïó∞Í≤∞Îêú ÎÑ§Ìä∏ÏõåÌÅ¨: ChainID ${networkInfo.chainId}`);
    
    // 3. AccessManagement Ïª®Ìä∏ÎûôÌä∏ Í∞ÄÏ†∏Ïò§Í∏∞
    const AccessManagement = await ethers.getContractFactory('AccessManagement');
    const accessManagement = await AccessManagement.attach(contractAddress);
    
    console.log(`üìù AccessManagement Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞Îê®: ${accessManagement.address}`);
    
    // 4. saveRequest Ìï®Ïàò Ìò∏Ï∂ú
    console.log(`\nüöÄ saveRequest Ìï®Ïàò Ìò∏Ï∂ú Ï§ë...`);
    const organizationName = 'samsung';
    
    const tx = await accessManagement.saveRequest(
      "0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199", // resourceOwner
      "Business Partnership", // purpose
      organizationName
    );
    console.log(`üìù Ìä∏ÎûúÏû≠ÏÖò Ï†ÑÏÜ°Îê®: ${tx.hash}`);
    
    // Ìä∏ÎûúÏû≠ÏÖò ÏôÑÎ£å ÎåÄÍ∏∞
    const receipt = await tx.wait();
    console.log(`‚úÖ Ìä∏ÎûúÏû≠ÏÖò ÏôÑÎ£å! Block: ${receipt.blockNumber}, Gas: ${receipt.gasUsed.toString()}`);

    // 5. Ìä∏ÎûúÏû≠ÏÖò Ìï¥ÏãúÎ•º ÏßÅÏ†ë ÏÇ¨Ïö©
    const txId = receipt.hash;
    console.log(`\nüìä Ìä∏ÎûúÏû≠ÏÖò Ìï¥Ïãú: ${txId}`);

    // 4. idxmngrÏóê Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ï†ÑÏÜ°
    console.log(`\nüìä idxmngrÏóê Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ï†ÑÏÜ° Ï§ë...`);
    
    const indexingClient = new IndexingClient({
      serverAddr: 'localhost:50052',
      protoPath: path.join(process.cwd(), '../idxmngr-go/protos/index_manager.proto')
    });

    try {
      // Ïó∞Í≤∞ ÏôÑÎ£å ÎåÄÍ∏∞
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
      const actualData = { OrganizationName: organizationName };
      const actualKeySize = calculateKeySize(actualData, config.KeyCol);
      console.log(`üìè Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: ${actualKeySize} (${organizationName})`);
      
      // Ïù∏Îç±Ïä§ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ Î∞è ÏûêÎèô ÏÉùÏÑ±
      const indexExists = await ensureIndexExists(indexingClient, network, config, actualKeySize);
      if (!indexExists) {
        throw new Error('Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ïã§Ìå®');
      }
      
      // InsertDatatoIdx Íµ¨Ï°∞Ï≤¥ ÏÉùÏÑ±
      const insertRequest = {
        IndexID: config.IndexID,
        BcList: [{
          TxId: txId,
          KeyCol: config.KeyCol,
          IndexableData: actualData
        }],
        ColName: config.KeyCol,
        TxId: txId,
        FilePath: config.FilePath,
        Network: config.Network
      };

      console.log(`\nüîå IndexingClientÎ°ú InsertIndexRequest Ìò∏Ï∂ú ÏãúÏûë...`);
      console.log(`   ÏÑúÎ≤Ñ Ï£ºÏÜå: localhost:50052`);
      console.log(`   ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞: ${JSON.stringify(insertRequest, null, 2)}`);
      
      // Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
      await indexingClient.insertData(insertRequest);
      console.log(`‚úÖ IndexingClient Ïù∏Îç±Ïã± ÏöîÏ≤≠ ÏÑ±Í≥µ!`);
      
    } catch (error) {
      console.error(`‚ùå IndexingClient Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ïã§Ìå®: ${error.message}`);
      throw error;
    } finally {
      indexingClient.close();
    }

    console.log(`‚úÖ idxmngr Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ï†ÑÏÜ° ÏôÑÎ£å!`);
    console.log(`   Network: ${config.Network}`);
    console.log(`   IndexID: ${config.IndexID}`);
    console.log(`   FilePath: ${config.FilePath}`);

    return {
      txHash: txId,
      requestId: txId,
      indexData: {
        txHash: txId,
        organization: organizationName,
        network: config.Network,
        indexID: config.IndexID
      }
    };

  } catch (error) {
    console.error(`‚ùå ${network} ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ïã§Ìå®: ${error.message}`);
    throw error;
  }
}

// Fabric ÎÑ§Ìä∏ÏõåÌÅ¨Ïö© Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ (PVD)
async function insertFabricData(network, config) {
  console.log(`\nüöÄ ${network.toUpperCase()} ÎÑ§Ìä∏ÏõåÌÅ¨ - Fabric PVD Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏãúÏûë...`);
  
  try {
    // FabricÏùÄ PVD Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©ÌïòÎØÄÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖò
    const obuId = `OBU_${Date.now()}`;
    const speed = Math.floor(Math.random() * 200); // 0-200 km/h ÎûúÎç§ ÏÜçÎèÑ
    const txId = `FABRIC_TX_${Date.now()}`;
    
    console.log(`üìä Fabric PVD Îç∞Ïù¥ÌÑ∞:`);
    console.log(`   OBU_ID: ${obuId}`);
    console.log(`   Speed: ${speed} km/h`);
    console.log(`   TxID: ${txId}`);

    // idxmngrÏóê Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ï†ÑÏÜ°
    console.log(`\nüìä idxmngrÏóê Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ï†ÑÏÜ° Ï§ë...`);
    
    const indexingClient = new IndexingClient({
      serverAddr: 'localhost:50052',
      protoPath: path.join(process.cwd(), '../idxmngr-go/protos/index_manager.proto')
    });

    try {
      // Ïó∞Í≤∞ ÏôÑÎ£å ÎåÄÍ∏∞
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (Speed Í∞í)
      const actualKeySize = calculateKeySize(speed, config.KeyCol);
      console.log(`üìè Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: ${actualKeySize} (Speed: ${speed})`);
      
      // Ïù∏Îç±Ïä§ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ Î∞è ÏûêÎèô ÏÉùÏÑ±
      const indexExists = await ensureIndexExists(indexingClient, network, config, actualKeySize);
      if (!indexExists) {
        throw new Error('Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ïã§Ìå®');
      }
      
      // InsertDatatoIdx Íµ¨Ï°∞Ï≤¥ ÏÉùÏÑ± (Fabric PVDÏö©)
      const insertRequest = {
        IndexID: config.IndexID,
        BcList: [{
          TxId: txId,
          Pvd: {
            ObuId: obuId,
            Speed: speed
          }
        }],
        ColName: config.KeyCol,
        TxId: txId,
        FilePath: config.FilePath,
        Network: config.Network
      };

      console.log(`\nüîå IndexingClientÎ°ú InsertIndexRequest Ìò∏Ï∂ú ÏãúÏûë...`);
      console.log(`   ÏÑúÎ≤Ñ Ï£ºÏÜå: localhost:50052`);
      console.log(`   ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞: ${JSON.stringify(insertRequest, null, 2)}`);
      
      // Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
      await indexingClient.insertData(insertRequest);
      console.log(`‚úÖ IndexingClient Ïù∏Îç±Ïã± ÏöîÏ≤≠ ÏÑ±Í≥µ!`);
      
    } catch (error) {
      console.error(`‚ùå IndexingClient Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ïã§Ìå®: ${error.message}`);
      throw error;
    } finally {
      indexingClient.close();
    }

    console.log(`‚úÖ idxmngr Ïù∏Îç±Ïã± ÏöîÏ≤≠ Ï†ÑÏÜ° ÏôÑÎ£å!`);
    console.log(`   Network: ${config.Network}`);
    console.log(`   IndexID: ${config.IndexID}`);
    console.log(`   FilePath: ${config.FilePath}`);

    return {
      txHash: txId,
      requestId: txId,
      indexData: {
        txHash: txId,
        obuId: obuId,
        speed: speed,
        network: config.Network,
        indexID: config.IndexID
      }
    };

  } catch (error) {
    console.error(`‚ùå ${network} ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ïã§Ìå®: ${error.message}`);
    throw error;
  }
}

// Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
async function main() {
  try {
    const { network, indexName, hardhatNetwork } = parseArgs();
    const config = getNetworkConfig(network, indexName);
    
    // Ïã§Ï†ú Ïó∞Í≤∞Îêú ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ïÎ≥¥ ÌôïÏù∏
    const provider = ethers.provider;
    const networkInfo = await provider.getNetwork();
    console.log(`üîó Ïã§Ï†ú Ïó∞Í≤∞Îêú ÎÑ§Ìä∏ÏõåÌÅ¨: ChainID ${networkInfo.chainId}`);
    
    console.log(`\nüöÄ ${network.toUpperCase()} ÎÑ§Ìä∏ÏõåÌÅ¨ - ${indexName} Ïù∏Îç±Ïä§ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏãúÏûë...`);
    console.log(`üåê Hardhat ÎÑ§Ìä∏ÏõåÌÅ¨: ${hardhatNetwork}`);
    
    let result;
    
    if (network === 'fabric') {
      result = await insertFabricData(network, config);
    } else {
      result = await insertEVMData(network, config);
    }
    
    console.log(`\nüéâ ${network.toUpperCase()} ÎÑ§Ìä∏ÏõåÌÅ¨ - ${indexName} Ïù∏Îç±Ïä§ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏÑ±Í≥µ!`);
    console.log(`   Tx Hash: ${result.txHash}`);
    console.log(`   Network: ${result.indexData.network}`);
    console.log(`   IndexID: ${result.indexData.indexID}`);
    console.log(`   FilePath: ${config.FilePath}`);
    
    console.log(`\nüìã Îã§Ïùå Îã®Í≥Ñ: Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏`);
    console.log(`   ÏòàÏãú: npx hardhat run verify-data.js --network ${hardhatNetwork}`);
    
  } catch (error) {
    console.error('\nüí• Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ïã§Ìå®:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { insertEVMData, insertFabricData, getNetworkConfig };
